<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="`Surface` is responsible for managing the pixels that a canvas draws into. The pixels can be allocated either in CPU memory (a raster surface) or on the GPU (a `RenderTarget` surface). `Surface` takes care of allocating a `Canvas` that will draw into the surface. Call `surface_get_canvas()` to use that canvas (but don’t delete it, it is owned by the surface). `Surface` always has non-zero dimensions. If there is a request for a new surface, and either of the requested dimensions are zero, then `None` will be returned."><title>Surface in skia_safe - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-aa0817cf.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="skia_safe" data-themes="" data-resource-suffix="" data-rustdoc-version="1.90.0 (1159e78c4 2025-09-14)" data-channel="1.90.0" data-search-js="search-fa3e91e5.js" data-settings-js="settings-5514c975.js" ><script src="../static.files/storage-68b7e25d.js"></script><script defer src="sidebar-items.js"></script><script defer src="../static.files/main-eebb9057.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-32bb7600.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc type"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../skia_safe/index.html">skia_<wbr>safe</a><span class="version">0.90.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Surface</a></h2><h3><a href="#aliased-type">Aliased Type</a></h3><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.canvas" title="canvas">canvas</a></li><li><a href="#method.direct_context" title="direct_context">direct_context</a></li><li><a href="#method.draw" title="draw">draw</a></li><li><a href="#method.from_backend_render_target" title="from_backend_render_target">from_backend_render_target</a></li><li><a href="#method.from_backend_texture" title="from_backend_texture">from_backend_texture</a></li><li><a href="#method.from_ca_metal_layer" title="from_ca_metal_layer">from_ca_metal_layer</a></li><li><a href="#method.from_mtk_view" title="from_mtk_view">from_mtk_view</a></li><li><a href="#method.generation_id" title="generation_id">generation_id</a></li><li><a href="#method.get_backend_render_target" title="get_backend_render_target">get_backend_render_target</a></li><li><a href="#method.get_backend_texture" title="get_backend_texture">get_backend_texture</a></li><li><a href="#method.height" title="height">height</a></li><li><a href="#method.image_info" title="image_info">image_info</a></li><li><a href="#method.image_snapshot" title="image_snapshot">image_snapshot</a></li><li><a href="#method.image_snapshot_with_bounds" title="image_snapshot_with_bounds">image_snapshot_with_bounds</a></li><li><a href="#method.make_temporary_image" title="make_temporary_image">make_temporary_image</a></li><li><a href="#method.new_null" title="new_null">new_null</a></li><li><a href="#method.new_raster" title="new_raster">new_raster</a></li><li><a href="#method.new_raster_direct" title="new_raster_direct">new_raster_direct</a></li><li><a href="#method.new_raster_n32_premul" title="new_raster_n32_premul">new_raster_n32_premul</a></li><li><a href="#method.new_render_target" title="new_render_target">new_render_target</a></li><li><a href="#method.new_surface" title="new_surface">new_surface</a></li><li><a href="#method.new_surface_with_dimensions" title="new_surface_with_dimensions">new_surface_with_dimensions</a></li><li><a href="#method.notify_content_will_change" title="notify_content_will_change">notify_content_will_change</a></li><li><a href="#method.peek_pixels" title="peek_pixels">peek_pixels</a></li><li><a href="#method.props" title="props">props</a></li><li><a href="#method.read_pixels" title="read_pixels">read_pixels</a></li><li><a href="#method.read_pixels_to_bitmap" title="read_pixels_to_bitmap">read_pixels_to_bitmap</a></li><li><a href="#method.read_pixels_to_pixmap" title="read_pixels_to_pixmap">read_pixels_to_pixmap</a></li><li><a href="#method.recording_context" title="recording_context">recording_context</a></li><li><a href="#method.replace_backend_texture" title="replace_backend_texture">replace_backend_texture</a></li><li><a href="#method.replace_backend_texture_with_mode" title="replace_backend_texture_with_mode">replace_backend_texture_with_mode</a></li><li><a href="#method.resolve_msaa" title="resolve_msaa">resolve_msaa</a></li><li><a href="#method.width" title="width">width</a></li><li><a href="#method.write_pixels_from_bitmap" title="write_pixels_from_bitmap">write_pixels_from_bitmap</a></li><li><a href="#method.write_pixels_from_pixmap" title="write_pixels_from_pixmap">write_pixels_from_pixmap</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-RCHandle%3CSkSurface%3E" title="Debug">Debug</a></li></ul></section><div id="rustdoc-modnav"><h2 class="in-crate"><a href="index.html">In crate skia_<wbr>safe</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="index.html">skia_safe</a></div><h1>Type Alias <span class="type">Surface</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/skia_safe/core/surface.rs.html#154">Source</a> </span></div><pre class="rust item-decl"><code>pub type Surface = <a class="struct" href="struct.RCHandle.html" title="struct skia_safe::RCHandle">RCHandle</a>&lt;SkSurface&gt;;</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is responsible for managing the pixels that a canvas draws into. The pixels can be
allocated either in CPU memory (a raster surface) or on the GPU (a <code>RenderTarget</code> surface).
<a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> takes care of allocating a <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> that will draw into the surface. Call
<code>surface_get_canvas()</code> to use that canvas (but don’t delete it, it is owned by the surface).
<a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> always has non-zero dimensions. If there is a request for a new surface, and either
of the requested dimensions are zero, then <code>None</code> will be returned.</p>
</div></details><h2 id="aliased-type" class="section-header">Aliased Type<a href="#aliased-type" class="anchor">§</a></h2><pre class="rust item-decl"><code>pub struct Surface(<span class="comment">/* private fields */</span>);</code></pre><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#172-255">Source</a><a href="#impl-RCHandle%3CSkSurface%3E" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_raster_direct" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#195-202">Source</a><h4 class="code-header">pub fn <a href="#method.new_raster_direct" class="fn">new_raster_direct</a>&lt;'pixels&gt;(
    image_info: &amp;<a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a>,
    pixels: &amp;'pixels mut [<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>],
    row_bytes: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Borrows.html" title="struct skia_safe::Borrows">Borrows</a>&lt;'pixels, <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a>&gt;&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use surfaces::wrap_pixels()</span></div></span></summary><div class="docblock"><p>Allocates raster <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> returned by <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> draws directly into pixels.</p>
<p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is returned if all parameters are valid.
Valid parameters include:
info dimensions are greater than zero;
info contains <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a> supported by raster surface;
pixels is not <code>None</code>;
<code>row_bytes</code> is large enough to contain info width pixels of <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>.</p>
<p>Pixel buffer size should be info height times computed <code>row_bytes</code>.
Pixels are not initialized.
To access pixels after drawing, <a href="struct.RCHandle.html#method.peek_pixels" title="method skia_safe::RCHandle::peek_pixels"><code>Self::peek_pixels()</code></a> or <a href="struct.RCHandle.html#method.read_pixels" title="method skia_safe::RCHandle::read_pixels"><code>Self::read_pixels()</code></a>.</p>
<ul>
<li><code>image_info</code> - width, height, <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>, <a href="type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>crate::ColorSpace</code></a>,
of raster surface; width and height must be greater than zero</li>
<li><code>pixels</code> - pointer to destination pixels buffer</li>
<li><code>row_bytes</code> - interval from one <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> row to the next</li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent fonts;
may be <code>None</code></li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_raster" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#225-231">Source</a><h4 class="code-header">pub fn <a href="#method.new_raster" class="fn">new_raster</a>(
    image_info: &amp;<a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a>,
    row_bytes: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use surfaces::raster()</span></div></span></summary><div class="docblock"><p>Allocates raster <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> returned by <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> draws directly into pixels.
Allocates and zeroes pixel memory. Pixel memory size is <code>image_info.height()</code> times
<code>row_bytes</code>, or times <code>image_info.min_row_bytes()</code> if <code>row_bytes</code> is zero.
Pixel memory is deleted when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is deleted.</p>
<p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is returned if all parameters are valid.
Valid parameters include:
info dimensions are greater than zero;
info contains <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a> supported by raster surface;
<code>row_bytes</code> is large enough to contain info width pixels of <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, or is zero.</p>
<p>If <code>row_bytes</code> is zero, a suitable value will be chosen internally.</p>
<ul>
<li><code>image_info</code> - width, height, <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>, <a href="type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>crate::ColorSpace</code></a>,
of raster surface; width and height must be greater than zero</li>
<li><code>row_bytes</code> - interval from one <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> row to the next; may be zero</li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent fonts;
may be <code>None</code></li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_raster_n32_premul" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#252-254">Source</a><h4 class="code-header">pub fn <a href="#method.new_raster_n32_premul" class="fn">new_raster_n32_premul</a>(size: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ISize.html" title="struct skia_safe::ISize">ISize</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use surfaces::raster_n32_premul()</span></div></span></summary><div class="docblock"><p>Allocates raster <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> returned by <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> draws directly into pixels.
Allocates and zeroes pixel memory. Pixel memory size is height times width times
four. Pixel memory is deleted when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is deleted.</p>
<p>Internally, sets <a href="type.ImageInfo.html" title="type skia_safe::ImageInfo"><code>ImageInfo</code></a> to width, height, native color type, and
<a href="enum.AlphaType.html#variant.Premul" title="variant skia_safe::AlphaType::Premul"><code>crate::AlphaType::Premul</code></a>.</p>
<p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is returned if width and height are greater than zero.</p>
<p>Use to create <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> that matches <a href="type.PMColor.html" title="type skia_safe::PMColor"><code>crate::PMColor</code></a>, the native pixel arrangement on
the platform. <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> drawn to output device skips converting its pixel format.</p>
<ul>
<li><code>width</code> - pixel column count; must be greater than zero</li>
<li><code>height</code> - pixel row count; must be greater than zero</li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E-1" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#258-468">Source</a><a href="#impl-RCHandle%3CSkSurface%3E-1" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from_backend_texture" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#279-297">Source</a><h4 class="code-header">pub fn <a href="#method.from_backend_texture" class="fn">from_backend_texture</a>(
    context: &amp;mut <a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>,
    backend_texture: &amp;<a class="type" href="gpu/ganesh/type.BackendTexture.html" title="type skia_safe::gpu::ganesh::BackendTexture">BackendTexture</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
    sample_cnt: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    color_type: <a class="enum" href="enum.ColorType.html" title="enum skia_safe::ColorType">ColorType</a>,
    color_space: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.ColorSpace.html" title="type skia_safe::ColorSpace">ColorSpace</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use gpu::surfaces::wrap_backend_texture()</span></div></span></summary><div class="docblock"><p>Wraps a GPU-backed texture into <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. Caller must ensure the texture is
valid for the lifetime of returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. If <code>sample_cnt</code> greater than zero,
creates an intermediate MSAA <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> which is used for drawing <code>backend_texture</code>.</p>
<p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is returned if all parameters are valid. <code>backend_texture</code> is valid if
its pixel configuration agrees with <code>color_space</code> and context; for instance, if
<code>backend_texture</code> has an sRGB configuration, then context must support sRGB,
and <code>color_space</code> must be present. Further, <code>backend_texture</code> width and height must
not exceed context capabilities, and the context must be able to support
back-end textures.</p>
<ul>
<li><code>context</code> - GPU context</li>
<li><code>backend_texture</code> - texture residing on GPU</li>
<li><code>sample_cnt</code> - samples per pixel, or 0 to disable full scene anti-aliasing</li>
<li><code>color_space</code> - range of colors; may be <code>None</code></li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_backend_render_target" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#320-336">Source</a><h4 class="code-header">pub fn <a href="#method.from_backend_render_target" class="fn">from_backend_render_target</a>(
    context: &amp;mut <a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>,
    backend_render_target: &amp;<a class="type" href="gpu/ganesh/type.BackendRenderTarget.html" title="type skia_safe::gpu::ganesh::BackendRenderTarget">BackendRenderTarget</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
    color_type: <a class="enum" href="enum.ColorType.html" title="enum skia_safe::ColorType">ColorType</a>,
    color_space: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.ColorSpace.html" title="type skia_safe::ColorSpace">ColorSpace</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use gpu::surfaces::wrap_backend_render_target()</span></div></span></summary><div class="docblock"><p>Wraps a GPU-backed buffer into <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. Caller must ensure <code>backend_render_target</code>
is valid for the lifetime of returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>.</p>
<p><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is returned if all parameters are valid. <code>backend_render_target</code> is valid if
its pixel configuration agrees with <code>color_space</code> and context; for instance, if
<code>backend_render_target</code> has an sRGB configuration, then context must support sRGB,
and <code>color_space</code> must be present. Further, <code>backend_render_target</code> width and height must
not exceed context capabilities, and the context must be able to support
back-end render targets.</p>
<ul>
<li><code>context</code> - GPU context</li>
<li><code>backend_render_target</code> - GPU intermediate memory buffer</li>
<li><code>color_space</code> - range of colors</li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_render_target" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#363-382">Source</a><h4 class="code-header">pub fn <a href="#method.new_render_target" class="fn">new_render_target</a>(
    context: &amp;mut <a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>,
    budgeted: <a class="struct" href="gpu/struct.Budgeted.html" title="struct skia_safe::gpu::Budgeted">Budgeted</a>,
    image_info: &amp;<a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a>,
    sample_count: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    surface_origin: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
    should_create_with_mips: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a>&gt;&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use gpu::surfaces::render_target()</span></div></span></summary><div class="docblock"><p>Returns <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> on GPU indicated by context. Allocates memory for
pixels, based on the width, height, and <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> in <a href="type.ImageInfo.html" title="type skia_safe::ImageInfo"><code>ImageInfo</code></a>.  budgeted
selects whether allocation for pixels is tracked by context. <code>image_info</code>
describes the pixel format in <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, and transparency in
<a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>, and color matching in <a href="type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>crate::ColorSpace</code></a>.</p>
<p><code>sample_count</code> requests the number of samples per pixel.
Pass zero to disable multi-sample anti-aliasing.  The request is rounded
up to the next supported count, or rounded down if it is larger than the
maximum supported count.</p>
<p><code>surface_origin</code> pins either the top-left or the bottom-left corner to the origin.</p>
<p><code>should_create_with_mips</code> hints that <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> returned by <a href="struct.RCHandle.html#method.image_snapshot" title="method skia_safe::RCHandle::image_snapshot"><code>Image::image_snapshot</code></a> is mip map.</p>
<ul>
<li><code>context</code> - GPU context</li>
<li><code>image_info</code> - width, height, <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>, <a href="type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>crate::ColorSpace</code></a>;
width, or height, or both, may be zero</li>
<li><code>sample_count</code> - samples per pixel, or 0 to disable full scene anti-aliasing</li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
<li><code>should_create_with_mips</code> - hint that <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> will host mip map images</li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if all parameters are valid; otherwise, <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_ca_metal_layer" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#407-427">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_ca_metal_layer" class="fn">from_ca_metal_layer</a>(
    context: &amp;mut <a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>,
    layer: <a class="type" href="gpu/mtl/type.Handle.html" title="type skia_safe::gpu::mtl::Handle">Handle</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
    sample_cnt: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    color_type: <a class="enum" href="enum.ColorType.html" title="enum skia_safe::ColorType">ColorType</a>,
    color_space: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.ColorSpace.html" title="type skia_safe::ColorSpace">ColorSpace</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
    drawable: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.pointer.html">*mut </a><a class="type" href="gpu/mtl/type.Handle.html" title="type skia_safe::gpu::mtl::Handle">Handle</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.65.0: Use gpu::surfaces::wrap_ca_metal_layer</span></div></span></summary><div class="docblock"><p>Creates <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> from CAMetalLayer.
Returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> takes a reference on the CAMetalLayer. The ref on the layer will be
released when the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is destroyed.</p>
<p>Only available when Metal API is enabled.</p>
<p>Will grab the current drawable from the layer and use its texture as a <code>backend_rt</code> to
create a renderable surface.</p>
<ul>
<li><code>context</code> - GPU context</li>
<li><code>layer</code> - <a href="gpu/mtl/type.Handle.html" title="type skia_safe::gpu::mtl::Handle"><code>gpu::mtl::Handle</code></a> (expected to be a CAMetalLayer*)</li>
<li><code>sample_cnt</code> - samples per pixel, or 0 to disable full scene anti-aliasing</li>
<li><code>color_space</code> - range of colors; may be <code>None</code></li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
<li><code>drawable</code> - Pointer to drawable to be filled in when this surface is
instantiated; may not be <code>None</code></li>
</ul>
<p>Returns: created <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>, or <code>None</code></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.from_mtk_view" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#449-467">Source</a><h4 class="code-header">pub unsafe fn <a href="#method.from_mtk_view" class="fn">from_mtk_view</a>(
    context: &amp;mut <a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>,
    mtk_view: <a class="type" href="gpu/mtl/type.Handle.html" title="type skia_safe::gpu::mtl::Handle">Handle</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
    sample_count: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>&gt;&gt;,
    color_type: <a class="enum" href="enum.ColorType.html" title="enum skia_safe::ColorType">ColorType</a>,
    color_space: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.ColorSpace.html" title="type skia_safe::ColorSpace">ColorSpace</a>&gt;&gt;,
    surface_props: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.65.0: Use gpu::surfaces::wrap_mtk_view</span></div></span></summary><div class="docblock"><p>Creates <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> from MTKView.
Returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> takes a reference on the <code>MTKView</code>. The ref on the layer will be
released when the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is destroyed.</p>
<p>Only available when Metal API is enabled.</p>
<p>Will grab the current drawable from the layer and use its texture as a <code>backend_rt</code> to
create a renderable surface.</p>
<ul>
<li><code>context</code> - GPU context</li>
<li><code>layer</code> - <a href="gpu/mtl/type.Handle.html" title="type skia_safe::gpu::mtl::Handle"><code>gpu::mtl::Handle</code></a> (expected to be a <code>MTKView*</code>)</li>
<li><code>sample_cnt</code> - samples per pixel, or 0 to disable full scene anti-aliasing</li>
<li><code>color_space</code> - range of colors; may be <code>None</code></li>
<li><code>surface_props</code> - LCD striping orientation and setting for device independent
fonts; may be <code>None</code></li>
</ul>
<p>Returns: created <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>, or <code>None</code></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E-2" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#470-526">Source</a><a href="#impl-RCHandle%3CSkSurface%3E-2" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.new_null" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#481-483">Source</a><h4 class="code-header">pub fn <a href="#method.new_null" class="fn">new_null</a>(size: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ISize.html" title="struct skia_safe::ISize">ISize</a>&gt;) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use surfaces::null()</span></div></span></summary><div class="docblock"><p>Returns <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> without backing pixels. Drawing to <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> returned from <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>
has no effect. Calling <a href="struct.RCHandle.html#method.image_snapshot" title="method skia_safe::RCHandle::image_snapshot"><code>Self::image_snapshot()</code></a> on returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> returns <code>None</code>.</p>
<ul>
<li><code>width</code> - one or greater</li>
<li><code>height</code> - one or greater</li>
</ul>
<p>Returns: <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> if width and height are positive; otherwise, <code>None</code></p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_MakeNull">https://fiddle.skia.org/c/@Surface_MakeNull</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.width" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#488-490">Source</a><h4 class="code-header">pub fn <a href="#method.width" class="fn">width</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns pixel count in each row; may be zero or greater.</p>
<p>Returns: number of pixel columns</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.height" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#496-498">Source</a><h4 class="code-header">pub fn <a href="#method.height" class="fn">height</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.i32.html">i32</a></h4></section></summary><div class="docblock"><p>Returns pixel row count; may be zero or greater.</p>
<p>Returns: number of pixel rows</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.image_info" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#501-505">Source</a><h4 class="code-header">pub fn <a href="#method.image_info" class="fn">image_info</a>(&amp;self) -&gt; <a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a></h4></section></summary><div class="docblock"><p>Returns an <a href="type.ImageInfo.html" title="type skia_safe::ImageInfo"><code>ImageInfo</code></a> describing the surface.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.generation_id" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#514-516">Source</a><h4 class="code-header">pub fn <a href="#method.generation_id" class="fn">generation_id</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u32.html">u32</a></h4></section></summary><div class="docblock"><p>Returns unique value identifying the content of <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. Returned value changes
each time the content changes. Content is changed by drawing, or by calling
<a href="struct.RCHandle.html#method.notify_content_will_change" title="method skia_safe::RCHandle::notify_content_will_change"><code>Self::notify_content_will_change()</code></a>.</p>
<p>Returns: unique content identifier</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_notifyContentWillChange">https://fiddle.skia.org/c/@Surface_notifyContentWillChange</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.notify_content_will_change" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#522-525">Source</a><h4 class="code-header">pub fn <a href="#method.notify_content_will_change" class="fn">notify_content_will_change</a>(
    &amp;mut self,
    mode: <a class="enum" href="surface/enum.ContentChangeMode.html" title="enum skia_safe::surface::ContentChangeMode">ContentChangeMode</a>,
) -&gt; &amp;mut Self</h4></section></summary><div class="docblock"><p>Notifies that <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents will be changed by code outside of Skia.
Subsequent calls to <a href="struct.RCHandle.html#method.generation_id" title="method skia_safe::RCHandle::generation_id"><code>Self::generation_id()</code></a> return a different value.</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_notifyContentWillChange">https://fiddle.skia.org/c/@Surface_notifyContentWillChange</a></p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E-3" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#542-628">Source</a><a href="#impl-RCHandle%3CSkSurface%3E-3" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.recording_context" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#546-548">Source</a><h4 class="code-header">pub fn <a href="#method.recording_context" class="fn">recording_context</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="gpu/ganesh/type.RecordingContext.html" title="type skia_safe::gpu::ganesh::RecordingContext">RecordingContext</a>&gt;</h4></section></summary><div class="docblock"><p>Returns the recording context being used by the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>.</p>
<p>Returns: the recording context, if available; <code>None</code> otherwise</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.direct_context" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#551-554">Source</a><h4 class="code-header">pub fn <a href="#method.direct_context" class="fn">direct_context</a>(&amp;self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="gpu/ganesh/type.DirectContext.html" title="type skia_safe::gpu::ganesh::DirectContext">DirectContext</a>&gt;</h4></section></summary><div class="docblock"><p>rust-skia helper, not in Skia</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_backend_texture" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#563-568">Source</a><h4 class="code-header">pub fn <a href="#method.get_backend_texture" class="fn">get_backend_texture</a>(
    &amp;mut self,
    handle_access: <a class="enum" href="surface/enum.BackendHandleAccess.html" title="enum skia_safe::surface::BackendHandleAccess">BackendHandleAccess</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="gpu/ganesh/type.BackendTexture.html" title="type skia_safe::gpu::ganesh::BackendTexture">BackendTexture</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use gpu::surfaces::get_backend_texture()</span></div></span></summary><div class="docblock"><p>Retrieves the back-end texture. If <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> has no back-end texture, <code>None</code>
is returned.</p>
<p>The returned <a href="gpu/ganesh/type.BackendTexture.html" title="type skia_safe::gpu::ganesh::BackendTexture"><code>gpu::BackendTexture</code></a> should be discarded if the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is drawn to or deleted.</p>
<p>Returns: GPU texture reference; <code>None</code> on failure</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.get_backend_render_target" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#581-586">Source</a><h4 class="code-header">pub fn <a href="#method.get_backend_render_target" class="fn">get_backend_render_target</a>(
    &amp;mut self,
    handle_access: <a class="enum" href="surface/enum.BackendHandleAccess.html" title="enum skia_safe::surface::BackendHandleAccess">BackendHandleAccess</a>,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="gpu/ganesh/type.BackendRenderTarget.html" title="type skia_safe::gpu::ganesh::BackendRenderTarget">BackendRenderTarget</a>&gt;</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.64.0: use gpu::surfaces::get_backend_render_target()</span></div></span></summary><div class="docblock"><p>Retrieves the back-end render target. If <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> has no back-end render target, <code>None</code>
is returned.</p>
<p>The returned <a href="gpu/ganesh/type.BackendRenderTarget.html" title="type skia_safe::gpu::ganesh::BackendRenderTarget"><code>gpu::BackendRenderTarget</code></a> should be discarded if the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is drawn to
or deleted.</p>
<p>Returns: GPU render target reference; <code>None</code> on failure</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace_backend_texture" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#597-603">Source</a><h4 class="code-header">pub fn <a href="#method.replace_backend_texture" class="fn">replace_backend_texture</a>(
    &amp;mut self,
    backend_texture: &amp;<a class="type" href="gpu/ganesh/type.BackendTexture.html" title="type skia_safe::gpu::ganesh::BackendTexture">BackendTexture</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>If the surface was made via <a href="struct.RCHandle.html#method.from_backend_texture" title="associated function skia_safe::RCHandle::from_backend_texture"><code>Self::from_backend_texture</code></a> then it’s backing texture may be
substituted with a different texture. The contents of the previous backing texture are
copied into the new texture. <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> state is preserved. The original sample count is
used. The <a href="gpu/ganesh/type.BackendFormat.html" title="type skia_safe::gpu::ganesh::BackendFormat"><code>gpu::BackendFormat</code></a> and dimensions of replacement texture must match that of
the original.</p>
<ul>
<li><code>backend_texture</code> - the new backing texture for the surface</li>
</ul>
</div></details><details class="toggle method-toggle" open><summary><section id="method.replace_backend_texture_with_mode" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#613-627">Source</a><h4 class="code-header">pub fn <a href="#method.replace_backend_texture_with_mode" class="fn">replace_backend_texture_with_mode</a>(
    &amp;mut self,
    backend_texture: &amp;<a class="type" href="gpu/ganesh/type.BackendTexture.html" title="type skia_safe::gpu::ganesh::BackendTexture">BackendTexture</a>,
    origin: <a class="enum" href="gpu/enum.SurfaceOrigin.html" title="enum skia_safe::gpu::SurfaceOrigin">SurfaceOrigin</a>,
    mode: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="enum" href="surface/enum.ContentChangeMode.html" title="enum skia_safe::surface::ContentChangeMode">ContentChangeMode</a>&gt;&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>If the surface was made via <a href="struct.RCHandle.html#method.from_backend_texture" title="associated function skia_safe::RCHandle::from_backend_texture"><code>Self::from_backend_texture()</code></a> then it’s backing texture may be
substituted with a different texture. The contents of the previous backing texture are
copied into the new texture. <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> state is preserved. The original sample count is
used. The <a href="gpu/ganesh/type.BackendFormat.html" title="type skia_safe::gpu::ganesh::BackendFormat"><code>gpu::BackendFormat</code></a> and dimensions of replacement texture must match that of
the original.</p>
<ul>
<li><code>backend_texture</code> - the new backing texture for the surface</li>
<li><code>mode</code> - Retain or discard current Content</li>
</ul>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E-4" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#630-943">Source</a><a href="#impl-RCHandle%3CSkSurface%3E-4" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.canvas" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#638-641">Source</a><h4 class="code-header">pub fn <a href="#method.canvas" class="fn">canvas</a>(&amp;mut self) -&gt; &amp;<a class="struct" href="struct.Canvas.html" title="struct skia_safe::Canvas">Canvas</a></h4></section></summary><div class="docblock"><p>Returns <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> that draws into <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>. Subsequent calls return the same <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a>.
<a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> returned is managed and owned by <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>, and is deleted when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>
is deleted.</p>
<p>Returns: drawing <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> for <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a></p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_getCanvas">https://fiddle.skia.org/c/@Surface_getCanvas</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_surface" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#660-664">Source</a><h4 class="code-header">pub fn <a href="#method.new_surface" class="fn">new_surface</a>(&amp;mut self, image_info: &amp;<a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Returns a compatible <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>, or <code>None</code>. Returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contains
the same raster, GPU, or null properties as the original. Returned <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>
does not share the same pixels.</p>
<p>Returns <code>None</code> if <code>image_info</code> width or height are zero, or if <code>image_info</code>
is incompatible with <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>.</p>
<ul>
<li><code>image_info</code> - width, height, <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>, <a href="type.ColorSpace.html" title="type skia_safe::ColorSpace"><code>crate::ColorSpace</code></a>,
of <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>; width and height must be greater than zero</li>
</ul>
<p>Returns: compatible <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> or <code>None</code></p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeSurface">https://fiddle.skia.org/c/@Surface_makeSurface</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.new_surface_with_dimensions" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#668-673">Source</a><h4 class="code-header">pub fn <a href="#method.new_surface_with_dimensions" class="fn">new_surface_with_dimensions</a>(
    &amp;mut self,
    dim: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.ISize.html" title="struct skia_safe::ISize">ISize</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;Self&gt;</h4></section></summary><div class="docblock"><p>Calls <a href="struct.RCHandle.html#method.new_surface" title="method skia_safe::RCHandle::new_surface"><code>Self::new_surface()</code></a> with the same <a href="type.ImageInfo.html" title="type skia_safe::ImageInfo"><code>ImageInfo</code></a> as this surface, but with the
specified width and height.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.image_snapshot" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#682-687">Source</a><h4 class="code-header">pub fn <a href="#method.image_snapshot" class="fn">image_snapshot</a>(&amp;mut self) -&gt; <a class="type" href="type.Image.html" title="type skia_safe::Image">Image</a></h4></section></summary><div class="docblock"><p>Returns <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> capturing <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents. Subsequent drawing to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents
are not captured. <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> allocation is accounted for if <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> was created with
<a href="gpu/struct.Budgeted.html#associatedconstant.Yes" title="associated constant skia_safe::gpu::Budgeted::Yes"><code>gpu::Budgeted::Yes</code></a>.</p>
<p>Returns: <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> initialized with <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeImageSnapshot">https://fiddle.skia.org/c/@Surface_makeImageSnapshot</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.make_temporary_image" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#700-702">Source</a><h4 class="code-header">pub fn <a href="#method.make_temporary_image" class="fn">make_temporary_image</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.Image.html" title="type skia_safe::Image">Image</a>&gt;</h4></section></summary><div class="docblock"><p>Returns an <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> capturing the current <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents. However, the contents of the
<a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> are only valid as long as no other writes to the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> occur. If writes to the
original <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> happen then contents of the <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> are undefined. However, continued use
of the <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> should not cause crashes or similar fatal behavior.</p>
<p>This API is useful for cases where the client either immediately destroys the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>
after the <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> is created or knows they will destroy the <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> before writing to the
<a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> again.</p>
<p>This API can be more performant than <a href="struct.RCHandle.html#method.image_snapshot" title="method skia_safe::RCHandle::image_snapshot"><code>Self::image_snapshot()</code></a> as it never does an internal copy
of the data assuming the user frees either the <a href="type.Image.html" title="type skia_safe::Image"><code>Image</code></a> or <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> as described above.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.image_snapshot_with_bounds" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#715-719">Source</a><h4 class="code-header">pub fn <a href="#method.image_snapshot_with_bounds" class="fn">image_snapshot_with_bounds</a>(
    &amp;mut self,
    bounds: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.AsRef.html" title="trait core::convert::AsRef">AsRef</a>&lt;<a class="struct" href="struct.IRect.html" title="struct skia_safe::IRect">IRect</a>&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="type" href="type.Image.html" title="type skia_safe::Image">Image</a>&gt;</h4></section></summary><div class="docblock"><p>Like the no-parameter version, this returns an image of the current surface contents.
This variant takes a rectangle specifying the subset of the surface that is of interest.
These bounds will be sanitized before being used.</p>
<ul>
<li>If bounds extends beyond the surface, it will be trimmed to just the intersection of
it and the surface.</li>
<li>If bounds does not intersect the surface, then this returns <code>None</code>.</li>
<li>If bounds == the surface, then this is the same as calling the no-parameter variant.</li>
</ul>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_makeImageSnapshot_2">https://fiddle.skia.org/c/@Surface_makeImageSnapshot_2</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.draw" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#733-751">Source</a><h4 class="code-header">pub fn <a href="#method.draw" class="fn">draw</a>(
    &amp;mut self,
    canvas: &amp;<a class="struct" href="struct.Canvas.html" title="struct skia_safe::Canvas">Canvas</a>,
    offset: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.Point.html" title="struct skia_safe::Point">Point</a>&gt;,
    sampling: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.SamplingOptions.html" title="struct skia_safe::SamplingOptions">SamplingOptions</a>&gt;,
    paint: <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;&amp;<a class="type" href="type.Paint.html" title="type skia_safe::Paint">Paint</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Draws <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> contents to canvas, with its top-left corner at <code>(offset.x, offset.y)</code>.</p>
<p>If <a href="type.Paint.html" title="type skia_safe::Paint"><code>Paint</code></a> paint is not <code>None</code>, apply <a href="type.ColorFilter.html" title="type skia_safe::ColorFilter"><code>crate::ColorFilter</code></a>, alpha, <a href="type.ImageFilter.html" title="type skia_safe::ImageFilter"><code>crate::ImageFilter</code></a>, and <a href="enum.BlendMode.html" title="enum skia_safe::BlendMode"><code>crate::BlendMode</code></a>.</p>
<ul>
<li><code>canvas</code> - <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> drawn into</li>
<li><code>offset.x</code> - horizontal offset in <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a></li>
<li><code>offset.y</code> - vertical offset in <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a></li>
<li><code>sampling</code> - what technique to use when sampling the surface pixels</li>
<li><code>paint</code> - <a href="type.Paint.html" title="type skia_safe::Paint"><code>Paint</code></a> containing <a href="enum.BlendMode.html" title="enum skia_safe::BlendMode"><code>crate::BlendMode</code></a>, <a href="type.ColorFilter.html" title="type skia_safe::ColorFilter"><code>crate::ColorFilter</code></a>, <a href="type.ImageFilter.html" title="type skia_safe::ImageFilter"><code>crate::ImageFilter</code></a>,
and so on; or <code>None</code></li>
</ul>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_draw">https://fiddle.skia.org/c/@Surface_draw</a></p>
</div></details><section id="method.peek_pixels" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#753-756">Source</a><h4 class="code-header">pub fn <a href="#method.peek_pixels" class="fn">peek_pixels</a>(&amp;mut self) -&gt; <a class="enum" href="https://doc.rust-lang.org/1.90.0/core/option/enum.Option.html" title="enum core::option::Option">Option</a>&lt;<a class="struct" href="struct.Pixmap.html" title="struct skia_safe::Pixmap">Pixmap</a>&lt;'_&gt;&gt;</h4></section><details class="toggle method-toggle" open><summary><section id="method.read_pixels_to_pixmap" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#791-794">Source</a><h4 class="code-header">pub fn <a href="#method.read_pixels_to_pixmap" class="fn">read_pixels_to_pixmap</a>(
    &amp;mut self,
    dst: &amp;<a class="struct" href="struct.Pixmap.html" title="struct skia_safe::Pixmap">Pixmap</a>&lt;'_&gt;,
    src: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVector.html" title="struct skia_safe::IVector">IPoint</a>&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Copies <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> of pixels to dst.</p>
<p>Source <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are (<code>src.x</code>, <code>src.y</code>) and <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> <code>(width(), height())</code>.
Destination <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(0, 0)</code> and <code>(dst.width(), dst.height())</code>.
Copies each readable pixel intersecting both rectangles, without scaling,
converting to <code>dst_color_type()</code> and <code>dst_alpha_type()</code> if required.</p>
<p>Pixels are readable when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is raster, or backed by a Ganesh GPU backend. Graphite
has deprecated this API in favor of the equivalent asynchronous API on
<code>skgpu::graphite::Context</code> (with an optional explicit synchonization).</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p>Pixel values are converted only if <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>
do not match. Only pixels within both source and destination rectangles
are copied. dst contents outside <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> intersection are unchanged.</p>
<p>Pass negative values for <code>src.x</code> or <code>src.y</code> to offset pixels across or down destination.</p>
<p>Does not copy, and returns <code>false</code> if:</p>
<ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a href="struct.Pixmap.html" title="struct skia_safe::Pixmap"><code>Pixmap</code></a> pixels could not be allocated.</li>
<li><code>dst.row_bytes()</code> is too small to contain one row of pixels.</li>
</ul>
<ul>
<li><code>dst</code> - storage for pixels copied from <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a></li>
<li><code>src_x</code> - offset into readable pixels on x-axis; may be negative</li>
<li><code>src_y</code> - offset into readable pixels on y-axis; may be negative</li>
</ul>
<p>Returns: <code>true</code> if pixels were copied</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_readPixels">https://fiddle.skia.org/c/@Surface_readPixels</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_pixels" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#827-847">Source</a><h4 class="code-header">pub fn <a href="#method.read_pixels" class="fn">read_pixels</a>(
    &amp;mut self,
    dst_info: &amp;<a class="type" href="type.ImageInfo.html" title="type skia_safe::ImageInfo">ImageInfo</a>,
    dst_pixels: &amp;mut [<a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.u8.html">u8</a>],
    dst_row_bytes: <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.usize.html">usize</a>,
    src: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVector.html" title="struct skia_safe::IVector">IPoint</a>&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Copies <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> of pixels from <a href="struct.Canvas.html" title="struct skia_safe::Canvas"><code>Canvas</code></a> into <code>dst_pixels</code>.</p>
<p>Source <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are (<code>src.x</code>, <code>src.y</code>) and <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> (width(), height()).
Destination <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are (0, 0) and (<code>dst_info</code>.width(), <code>dst_info</code>.height()).
Copies each readable pixel intersecting both rectangles, without scaling,
converting to <code>dst_info_color_type()</code> and <code>dst_info_alpha_type()</code> if required.</p>
<p>Pixels are readable when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is raster, or backed by a Ganesh GPU backend. Graphite
has deprecated this API in favor of the equivalent asynchronous API on
<code>skgpu::graphite::Context</code> (with an optional explicit synchonization).</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p>Pixel values are converted only if <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>
do not match. Only pixels within both source and destination rectangles
are copied. <code>dst_pixels</code> contents outside <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> intersection are unchanged.</p>
<p>Pass negative values for <code>src.x</code> or <code>src.y</code> to offset pixels across or down destination.</p>
<p>Does not copy, and returns <code>false</code> if:</p>
<ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> pixels could not be converted to <code>dst_info.color_type()</code> or <code>dst_info.alpha_type()</code>.</li>
<li><code>dst_row_bytes</code> is too small to contain one row of pixels.</li>
</ul>
<ul>
<li><code>dst_info</code> - width, height, <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a>, and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a> of <code>dst_pixels</code></li>
<li><code>dst_pixels</code> - storage for pixels; <code>dst_info.height()</code> times <code>dst_row_bytes</code>, or larger</li>
<li><code>dst_row_bytes</code> - size of one destination row; <code>dst_info.width()</code> times pixel size, or larger</li>
<li><code>src.x</code> - offset into readable pixels on x-axis; may be negative</li>
<li><code>src.y</code> - offset into readable pixels on y-axis; may be negative</li>
</ul>
<p>Returns: <code>true</code> if pixels were copied</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.read_pixels_to_bitmap" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#884-887">Source</a><h4 class="code-header">pub fn <a href="#method.read_pixels_to_bitmap" class="fn">read_pixels_to_bitmap</a>(
    &amp;mut self,
    bitmap: &amp;<a class="type" href="type.Bitmap.html" title="type skia_safe::Bitmap">Bitmap</a>,
    src: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVector.html" title="struct skia_safe::IVector">IPoint</a>&gt;,
) -&gt; <a class="primitive" href="https://doc.rust-lang.org/1.90.0/std/primitive.bool.html">bool</a></h4></section></summary><div class="docblock"><p>Copies <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> of pixels from <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> into bitmap.</p>
<p>Source <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are (<code>src.x</code>, <code>src.y</code>) and <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> (width(), height()).
Destination <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(0, 0)</code> and <code>(bitmap.width(), bitmap.height())</code>.
Copies each readable pixel intersecting both rectangles, without scaling,
converting to <code>bitmap.color_type()</code> and <code>bitmap.alpha_type()</code> if required.</p>
<p>Pixels are readable when <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is raster, or backed by a Ganesh GPU backend. Graphite
has deprecated this API in favor of the equivalent asynchronous API on
<code>skgpu::graphite::Context</code> (with an optional explicit synchonization).</p>
<p>The destination pixel storage must be allocated by the caller.</p>
<p>Pixel values are converted only if <a href="enum.ColorType.html" title="enum skia_safe::ColorType"><code>crate::ColorType</code></a> and <a href="enum.AlphaType.html" title="enum skia_safe::AlphaType"><code>crate::AlphaType</code></a>
do not match. Only pixels within both source and destination rectangles
are copied. dst contents outside <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> intersection are unchanged.</p>
<p>Pass negative values for <code>src.x</code> or <code>src.y</code> to offset pixels across or down destination.</p>
<p>Does not copy, and returns <code>false</code> if:</p>
<ul>
<li>Source and destination rectangles do not intersect.</li>
<li><a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> pixels could not be converted to <code>dst.color_type()</code> or <code>dst.alpha_type()</code>.</li>
<li>dst pixels could not be allocated.</li>
<li><code>dst.row_bytes()</code> is too small to contain one row of pixels.</li>
</ul>
<ul>
<li><code>dst</code> - storage for pixels copied from <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a></li>
<li><code>src.x</code> - offset into readable pixels on x-axis; may be negative</li>
<li><code>src.y</code> - offset into readable pixels on y-axis; may be negative</li>
</ul>
<p>Returns: <code>true</code> if pixels were copied</p>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_readPixels_3">https://fiddle.skia.org/c/@Surface_readPixels_3</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_pixels_from_pixmap" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#908-911">Source</a><h4 class="code-header">pub fn <a href="#method.write_pixels_from_pixmap" class="fn">write_pixels_from_pixmap</a>(
    &amp;mut self,
    src: &amp;<a class="struct" href="struct.Pixmap.html" title="struct skia_safe::Pixmap">Pixmap</a>&lt;'_&gt;,
    dst: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVector.html" title="struct skia_safe::IVector">IPoint</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Copies <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> of pixels from the src <a href="struct.Pixmap.html" title="struct skia_safe::Pixmap"><code>Pixmap</code></a> to the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>.</p>
<p>Source <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(0, 0)</code> and <code>(src.width(), src.height())</code>.
Destination <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(</code>dst.x<code>, </code>dst.y<code>)</code> and
(<code>dst.x</code> + Surface width(), <code>dst.y</code> + Surface height()).</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling,
converting to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> <code>color_type()</code> and <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> <code>alpha_type()</code> if required.</p>
<ul>
<li><code>src</code> - storage for pixels to copy to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a></li>
<li><code>dst.x</code> - x-axis position relative to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> to begin copy; may be negative</li>
<li><code>dst.y</code> - y-axis position relative to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> to begin copy; may be negative</li>
</ul>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_writePixels">https://fiddle.skia.org/c/@Surface_writePixels</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.write_pixels_from_bitmap" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#927-933">Source</a><h4 class="code-header">pub fn <a href="#method.write_pixels_from_bitmap" class="fn">write_pixels_from_bitmap</a>(
    &amp;mut self,
    bitmap: &amp;<a class="type" href="type.Bitmap.html" title="type skia_safe::Bitmap">Bitmap</a>,
    dst: impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;<a class="struct" href="struct.IVector.html" title="struct skia_safe::IVector">IPoint</a>&gt;,
)</h4></section></summary><div class="docblock"><p>Copies <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> of pixels from the src <a href="type.Bitmap.html" title="type skia_safe::Bitmap"><code>Bitmap</code></a> to the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a>.</p>
<p>Source <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(0, 0)</code> and <code>(src.width(), src.height())</code>.
Destination <a href="struct.Rect.html" title="struct skia_safe::Rect"><code>crate::Rect</code></a> corners are <code>(</code>dst.x<code>, </code>dst.y<code>)</code> and
<code>(</code>dst.x<code>+ Surface width(),</code>dst.y<code> + Surface height())</code>.</p>
<p>Copies each readable pixel intersecting both rectangles, without scaling,
converting to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> <code>color_type()</code> and <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> <code>alpha_type()</code> if required.</p>
<ul>
<li><code>src</code> - storage for pixels to copy to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a></li>
<li><code>dst.x</code> - x-axis position relative to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> to begin copy; may be negative</li>
<li><code>dst.y</code> - y-axis position relative to <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> to begin copy; may be negative</li>
</ul>
<p>example: <a href="https://fiddle.skia.org/c/@Surface_writePixels_2">https://fiddle.skia.org/c/@Surface_writePixels_2</a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.props" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#938-940">Source</a><h4 class="code-header">pub fn <a href="#method.props" class="fn">props</a>(&amp;self) -&gt; &amp;<a class="struct" href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps">SurfaceProps</a></h4></section></summary><div class="docblock"><p>Returns <a href="struct.SurfaceProps.html" title="struct skia_safe::SurfaceProps"><code>SurfaceProps</code></a> for surface.</p>
<p>Returns: LCD striping orientation and setting for device independent fonts</p>
</div></details></div></details><details class="toggle implementors-toggle" open><summary><section id="impl-RCHandle%3CSkSurface%3E-5" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#947-963">Source</a><a href="#impl-RCHandle%3CSkSurface%3E-5" class="anchor">§</a><h3 class="code-header">impl <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.resolve_msaa" class="method"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#960-962">Source</a><h4 class="code-header">pub fn <a href="#method.resolve_msaa" class="fn">resolve_msaa</a>(&amp;mut self)</h4></section><span class="item-info"><div class="stab deprecated"><span class="emoji">👎</span><span>Deprecated since 0.65.0: Use gpu::surfaces::resolve_msaa</span></div></span></summary><div class="docblock"><p>If a surface is GPU texture backed, is being drawn with MSAA, and there is a resolve
texture, this call will insert a resolve command into the stream of gpu commands. In order
for the resolve to actually have an effect, the work still needs to be flushed and submitted
to the GPU after recording the resolve command. If a resolve is not supported or the
<a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> has no dirty work to resolve, then this call is a no-op.</p>
<p>This call is most useful when the <a href="type.Surface.html" title="type skia_safe::Surface"><code>Surface</code></a> is created by wrapping a single sampled gpu
texture, but asking Skia to render with MSAA. If the client wants to use the wrapped texture
outside of Skia, the only way to trigger a resolve is either to call this command or use
<a href="struct.RCHandle.html#method.flush" title="method skia_safe::RCHandle::flush"><code>Self::flush()</code></a>.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-RCHandle%3CSkSurface%3E" class="impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#161-170">Source</a><a href="#impl-Debug-for-RCHandle%3CSkSurface%3E" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="type" href="type.Surface.html" title="type skia_safe::Surface">Surface</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../src/skia_safe/core/surface.rs.html#162-169">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/1.90.0/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/1.90.0/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/1.90.0/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><script src="../type.impl/skia_safe/struct.RCHandle.js" data-self-path="skia_safe::core::surface::Surface" async></script></section></div></main></body></html>